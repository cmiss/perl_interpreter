!#### Module: PERL_INTERPRETER_F
!###  Description:
!###    This module contains the buffer routines to allow cmiss to use the
!###    command interpreter as a standalone library from Fortran.
!###    $Id$

!
!==============================================================================
!

!!MODULE USER_DATA

!!  USE KINDS

!!  IMPLICIT NONE

!!  TYPE USER_DATA
!!    INTEGER(INTG) :: COMFILE_READ_LEVEL
!!    CHARACTER, POINTER :: PROMPT(:)
!!  END TYPE USER_DATA

!!END MODULE USER_DATA
!
!==============================================================================
!

MODULE INTERPRETER_STATUS
  USE KINDS
  IMPLICIT NONE
  INTEGER(INTG), PARAMETER :: SUCCESS_STATUS = 1
  INTEGER(INTG), PARAMETER :: FAILURE_STATUS = 0
END MODULE INTERPRETER_STATUS
  
!
!==============================================================================
!

RECURSIVE SUBROUTINE EXECUTE_COMMAND(C_COMMAND_STRING,USER_DATA,QUIT,STATUS)

  USE KINDS
  USE C_CHARS
  USE INTERPRETER_STATUS
  
  IMPLICIT NONE

  !Argument Variables
  TYPE(C_CHAR_TYPE), INTENT(IN) :: C_COMMAND_STRING(*)
  TYPE(VOID_TYPE), INTENT(INOUT) :: USER_DATA
  LOGICAL, INTENT(INOUT) :: QUIT
  INTEGER(INTG), INTENT(OUT) :: STATUS
  !Interfaces
  INTERFACE
    SUBROUTINE EVALUATE_COMMAND_LINE(COMFILE_READ_LEVEL,QUIT,COMMAND_LINE,&
      & INTERPRETED_LINE,PROMPT,ERR,F_ERROR)
      USE KINDS
      INTEGER(INTG), INTENT(INOUT) :: COMFILE_READ_LEVEL
      LOGICAL, INTENT(INOUT) :: QUIT
      CHARACTER(LEN=*), INTENT(IN) :: COMMAND_LINE,INTERPRETED_LINE
      CHARACTER(LEN=*), INTENT(INOUT) :: PROMPT
      INTEGER(INTG), INTENT(OUT) :: ERR
      CHARACTER(LEN=*), INTENT(OUT) :: F_ERROR
    END SUBROUTINE EVALUATE_COMMAND_LINE
  END INTERFACE
  !Local Variables
  INTEGER(INTG) :: ERR
  !At present COMFILE_READ_LEVEL and PROMPT are unused in EVALUATE_COMMAND_LINE
  INTEGER(INTG) :: COMFILE_READ_LEVEL = -1
  CHARACTER(LEN=60) ::&
    & PROMPT = "perl_interpreter_f.f90: PROMPT not intended for use"
  CHARACTER(LEN=1024) :: F_ERROR

  CALL EVALUATE_COMMAND_LINE(COMFILE_READ_LEVEL,QUIT," ",&
    & CHARACTER(C_COMMAND_STRING(:STRLEN(C_COMMAND_STRING))),&
    & PROMPT,ERR,F_ERROR)

  IF(ERR==0) THEN
    STATUS = SUCCESS_STATUS
  ELSE
    STATUS = FAILURE_STATUS
  ENDIF

END SUBROUTINE EXECUTE_COMMAND

!
!==============================================================================
!

SUBROUTINE FINALISE_INTERPRETER(ERR,F_ERROR)
  
  USE KINDS
  USE INTERPRETER_STATUS
  
  IMPLICIT NONE

  !Argument Variables
  INTEGER(INTG), INTENT(OUT) :: ERR
  CHARACTER(LEN=*), INTENT(OUT) :: F_ERROR
  !Local Variables
  INTEGER(INTG) :: STATUS

  CALL DESTROY_INTERPRETER(STATUS)

  IF(STATUS==SUCCESS_STATUS) THEN
    ERR = 0
  ELSE
    ERR = 1
    F_ERROR = " "
  ENDIF

END SUBROUTINE FINALISE_INTERPRETER

!
!==============================================================================
!

SUBROUTINE INITIALISE_INTERPRETER(ERR,F_ERROR)
  
  USE KINDS
  USE INTERPRETER_STATUS
  
  IMPLICIT NONE

  !Argument Variables
  INTEGER(INTG), INTENT(OUT) :: ERR
  CHARACTER(LEN=*), INTENT(OUT) :: F_ERROR
  !Local Variables
  INTEGER(INTG) :: STATUS

  CALL CREATE_INTERPRETER(STATUS)

  IF(STATUS==SUCCESS_STATUS) THEN
    ERR = 0
  ELSE
    ERR = 1
    F_ERROR = " "
  ENDIF

END SUBROUTINE INITIALISE_INTERPRETER

!
!==============================================================================
!

RECURSIVE SUBROUTINE PROCESS_COMMAND(COMFILE_READ_LEVEL,QUIT,F_COMMAND_LINE,&
  & PROMPT,ERR,F_ERROR)
  
  USE KINDS
  USE C_CHARS
  USE INTERPRETER_STATUS
  
  IMPLICIT NONE

  !Argument Variables
  INTEGER(INTG), INTENT(INOUT) :: COMFILE_READ_LEVEL
  LOGICAL, INTENT(INOUT) :: QUIT
  CHARACTER(LEN=*), INTENT(IN) :: F_COMMAND_LINE
  CHARACTER(LEN=*), INTENT(INOUT) :: PROMPT
  INTEGER(INTG), INTENT(OUT) :: ERR
  CHARACTER(LEN=*), INTENT(OUT) :: F_ERROR
  !Local Variables
  TYPE(VOID_TYPE) :: USER_DATA
  INTEGER(INTG) :: STATUS

  EXTERNAL EXECUTE_COMMAND

  CALL INTERPRET_COMMAND(C_STRING(F_COMMAND_LINE),USER_DATA,&
    & QUIT,EXECUTE_COMMAND,STATUS)

  IF(STATUS==SUCCESS_STATUS) THEN
    ERR = 0
  ELSE
    ERR = 1
    F_ERROR = " "
  ENDIF

END SUBROUTINE PROCESS_COMMAND

!
!==============================================================================
!

SUBROUTINE SET_USER_CHARACTER(NAME,VALUE,ERR)
  
  USE KINDS
  USE C_CHARS
  USE INTERPRETER_STATUS
 
  IMPLICIT NONE

  !Argument Variables
  CHARACTER(LEN=*), INTENT(IN) :: NAME,VALUE
  INTEGER(INTG), INTENT(OUT) :: ERR
  !Local Variables
  INTEGER(INTG) :: STATUS

  EXTERNAL EXECUTE_COMMAND

  ! !!Need to quote 's
  CALL INTERPRETER_SET_STRING(C_STRING(NAME),C_STRING(VALUE),STATUS)

  IF(STATUS==SUCCESS_STATUS) THEN
    ERR = 0
  ELSE
    ERR = 1
  ENDIF

END SUBROUTINE SET_USER_CHARACTER

!
!==============================================================================
!

SUBROUTINE SET_USER_DOUBLE(NAME,VALUE,ERR)
  
  USE KINDS
  USE C_CHARS
  USE INTERPRETER_STATUS
 
  IMPLICIT NONE

  !Argument Variables
  CHARACTER(LEN=*), INTENT(IN) :: NAME
  REAL(DBLP), INTENT(IN) :: VALUE
  INTEGER(INTG), INTENT(OUT) :: ERR
  !Local Variables
  INTEGER(INTG) :: STATUS

  EXTERNAL EXECUTE_COMMAND

  ! !!Need to quote 's
  CALL INTERPRETER_SET_DOUBLE(C_STRING(NAME),VALUE,STATUS)

  IF(STATUS==SUCCESS_STATUS) THEN
    ERR = 0
  ELSE
    ERR = 1
  ENDIF

END SUBROUTINE SET_USER_DOUBLE

!
!==============================================================================
!

SUBROUTINE SET_USER_INTEGER(NAME,VALUE,ERR)
  
  USE KINDS
  USE C_CHARS
  USE INTERPRETER_STATUS
 
  IMPLICIT NONE

  !Argument Variables
  CHARACTER(LEN=*), INTENT(IN) :: NAME
  INTEGER(INTG), INTENT(IN) :: VALUE
  INTEGER(INTG), INTENT(OUT) :: ERR
  !Local Variables
  INTEGER(INTG) :: STATUS

  EXTERNAL EXECUTE_COMMAND

  ! !!Need to quote 's
  CALL INTERPRETER_SET_INTEGER(C_STRING(NAME),VALUE,STATUS)

  IF(STATUS==SUCCESS_STATUS) THEN
    ERR = 0
  ELSE
    ERR = 1
  ENDIF

END SUBROUTINE SET_USER_INTEGER
